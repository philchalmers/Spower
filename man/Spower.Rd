% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Spower.R
\name{Spower}
\alias{Spower}
\title{Simulation-based Power Analysis}
\usage{
Spower(
  ...,
  sim_function,
  interval,
  power = NA,
  sig.level = 0.05,
  replications = 10000,
  integer,
  beta_alpha = NULL,
  parallel = FALSE,
  cl = NULL,
  ncores = parallelly::availableCores(omit = 1L),
  verbose = TRUE
)
}
\arguments{
\item{...}{a set of conditions to use in the simulation that must match the
arguments in the function \code{sim_function}. Internally these arguments
are passed to either \code{\link{SimSolve}} or
\code{\link{runSimulation}} depending on which element (including
the \code{power} and \code{sig.level} arguments) is set to \code{NA}}

\item{sim_function}{function that both creates the data and returns a single
p-value for the analysis of interest}

\item{interval}{search interval to use when \code{\link{SimSolve}} is required}

\item{power}{power level to use. If set to \code{NA} then the empirical power
will be estimated given the fixed \code{conditions} input
(e.g., for post-hoc power analysis)}

\item{sig.level}{alpha level to use. If set to \code{NA} then the empirical
alpha will be estimated given the fixed \code{conditions} input
(e.g., for criterion power analysis)}

\item{replications}{number of replications to use when
\code{\link{runSimulation}} is required}

\item{integer}{a logical value indicating whether the search iterations
use integers or doubles.
Automatically set to \code{FALSE} if \code{interval} contains
non-integer numbers, though in general this should be set explicitly}

\item{beta_alpha}{ratio to use in compromise analyses corresponding to
the Type II errors (beta) over the Type I error (alpha). Ratios greater
than 1 indicate that Type I errors are worse than Type II, while ratios
less than one the opposite. A ratio equal to 1 gives an equal trade-off
between Type I and Type II errors}

\item{parallel}{for parallel computing for slower simulation experiments
(see \code{\link{runSimulation}} for details)}

\item{cl}{see \code{\link{runSimulation}}}

\item{ncores}{see \code{\link{runSimulation}}}

\item{verbose}{logical; should information be printed to the console?}
}
\description{
General purpose function that serves as a power-focused wrapper to the
\code{SimDesign} package's \code{\link{runSimulation}} and
\code{\link{SimSolve}} functions.
}
\examples{


############################
# Independent samples t-test
############################

# Internally defined p_t.test function
args(p_t.test)    # arguments required for Spower()
# help(p_t.test)  # additional information

# p_* functions generate data and return single p-value
p_t.test(n=50, d=.5)
p_t.test(n=50, d=.5)

# Estimate power given fixed inputs (post-hoc power analysis)
Spower(n = 50, d = .5, sim_function=p_t.test)

\dontrun{

# Same as above, but executed with multiple cores (not run)
# Spower(n = 50, d = .5, sim_function=p_t.test, parallel=TRUE)

# Solve N to get .80 power (a priori power analysis)
out <- Spower(n = NA, d = .5, sim_function=p_t.test,
          	 power = .8, interval=c(2,500))
# total sample size required
out$n * 2

# similar information from pwr package
pwr <- pwr::pwr.t.test(d=.5, power=.80)
pwr
pwr$n * 2

# Solve d to get .80 power (sensitivity power analysis)
Spower(n = 50, d = NA, sim_function=p_t.test,
  	  power=.80, interval=c(.1, 2))

pwr::pwr.t.test(n=50, power=.80) # compare

# Solve alpha that would give power of .80 (criterion power analysis)
Spower(n = 50, d = .5, sim_function=p_t.test,
	   interval=c(.0001, .8), power=.80, sig.level=NA)

# Solve beta/alpha ratio to specific error trade-off constant
#   (compromise power analysis)
Spower(n = 50, d = .5, sim_function=p_t.test, beta_alpha = 2)


###############
# Customization
###############

#   Make edits to the function for customization
if(interactive()){
    new.p_t.test <- edit(p_t.test)
    args(new.p_t.test)
    body(new.p_t.test)
}

# Alternatively, define a custom function (potentially based on the template)
new.p_t.test <- function(n, d, var.equal=FALSE, group_ratio=1, df=10){

    # Welch power analysis with asymmetric distributions
    # group1 as large as group2 by default

    # degree of skewness controlled via chi-squared distribution's df
    group1 <- rchisq(group_ratio*n, df=df)
    group1 <-  (group1 - df) / sqrt(2*df)   # Adjusted mean to 0, sd = 1
    group2 <- rnorm(n, mean=d)
    dat <- data.frame(group = factor(rep(c('G1', 'G2'),
                                     times = c(group_ratio*n, n))),
    				  DV = c(group1, group2))
    p <- t.test(DV ~ group, dat, var.equal=var.equal)$p.value
    p
}

# Solve N to get .80 power (a priori power analysis), using defaults
Spower(n = NA, d = .5, sim_function=new.p_t.test,
       power=.8, interval=c(2,500))

# Solve N to get .80 power (a priori power analysis), assuming
#   equal variances, control 2x as large as treatment group, large skewness
out <- Spower(n = NA, d = .5, var.equal=TRUE, group_ratio=2, df=3,
              sim_function=new.p_t.test, power=.8, interval=c(2,500))

# total sample size required
out$N * 2 + out$N

# should different alpha level be used given the assumption violations?
TypeI <- Spower(n = 50, d = 0, var.equal=TRUE, group_ratio=2, df=3,
                sim_function=new.p_t.test, replications=30000)
TypeI
se <- with(TypeI, sqrt(sig.level * (1-sig.level) / REPLICATIONS))
TypeI$sig.level + qnorm(c(.025, .975)) * se  # 95\% CI
TypeI$power


}
}
