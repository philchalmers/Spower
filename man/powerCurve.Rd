% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerCurve.R
\name{powerCurve}
\alias{powerCurve}
\title{Draw power curve from simulation functions}
\usage{
powerCurve(
  sim,
  varying,
  ...,
  interval = NULL,
  power = NA,
  sig.level = 0.05,
  replications = 1000,
  integer,
  prior = NULL,
  plotCI = TRUE,
  plotly = TRUE,
  parallel = FALSE,
  cl = NULL,
  ncores = parallelly::availableCores(omit = 1L),
  predCI = 0.95,
  predCI.tol = 0.01,
  verbose = TRUE,
  check.interval = FALSE,
  maxiter = 50,
  wait.time = NULL,
  control = list()
)
}
\arguments{
\item{sim}{function that both creates the data and returns a single
p-value for the analysis of interest}

\item{varying}{either a vector of values to substitute into the missing \code{...}
terms or a structure created from \code{\link[SimDesign]{createDesign}}.
The benefit of the ladder is that multiple factors can vary, and NA
placeholders will not be required. Requires \code{power} to be set to \code{NA}.

Note that only the first three columns in this object will be plotted using
the x-y, colour, and facet wrap aesthetics, respectively. However,
if necessary the data can be extracted for further visualizations via
\code{\link[ggplot2]{ggplot_build}} to provide more customized control}

\item{...}{a set of conditions to use in the simulation that must match the
arguments in the function \code{sim}. See \code{\link{Spower}}}

\item{interval}{search interval to use when \code{\link[SimDesign]{SimSolve}} is required.
Can be a vector of length two to apply the same interval across
the \code{varying} information or a \code{matrix} with two columns
to apply intervals on a per-row basis}

\item{power}{power level to use. If set to \code{NA} then the empirical power
will be estimated given the fixed \code{...} input; otherwise,
can be specified as a vector to solve the missing elements in
\code{...}}

\item{sig.level}{see \code{\link{Spower}}}

\item{replications}{see \code{\link{Spower}}, though set to 1000 instead of
10000}

\item{integer}{see \code{\link{Spower}}}

\item{prior}{see \code{\link{Spower}}}

\item{plotCI}{logical; include confidence/prediction intervals in plots?}

\item{plotly}{logical; draw the graphic into the interactive \code{plotly}
interface? If \code{FALSE} the ggplot2 object will be returned instead}

\item{parallel}{see \code{\link{Spower}}}

\item{cl}{see \code{\link{Spower}}}

\item{ncores}{see \code{\link{Spower}}}

\item{predCI}{see \code{\link{Spower}}}

\item{predCI.tol}{see \code{\link{Spower}}}

\item{verbose}{see \code{\link{Spower}}}

\item{check.interval}{see \code{\link{Spower}}, though is set to \code{FALSE}
by default instead}

\item{maxiter}{see \code{\link{Spower}}, though set to 50 instead of 150}

\item{wait.time}{see \code{\link{Spower}}}

\item{control}{see \code{\link{Spower}}}
}
\value{
a ggplot2 object
}
\description{
Draws power curves that either a) estimate the power given a
set of varying conditions or b) solves a set of root conditions
given fixed values of power. Confidence/prediction intervals are
included in the output to reflect the estimate uncertainties, though note
that fewer replications/iterations are used compared to
\code{\link{Spower}} as the goal is visualization of competing
variable inputs rather than precision of a given input.
}
\examples{
\dontrun{

# estimate power given varying sample sizes
gg <- powerCurve(p_t.test, varying=c(30, 90, 270, 550), n=NA, d=0.2)

# alternatively, specifying varying as a createDesign() object (does not
# require NA placeholders)
varying <- createDesign(n=c(30, 90, 270, 550))
gg <- powerCurve(p_t.test, varying=varying, d=0.2)

# also equivalent, though no CIs plotted
varying <- createDesign(n=c(30, 90, 270, 550), d=0.2)
gg <- powerCurve(p_t.test, varying=varying, plotCI=FALSE)

#####

# Because output is a ggplot2 object can be modified
gg + geom_text(aes(label=power), size=5, colour='red', nudge_y=.05) +
  ylab(expression(1-beta)) + theme_grey()

# increase precision by using 10000 replications. Parallel computations
# generally recommended in this case to save time
powerCurve(p_t.test, varying=c(30, 90, 270, 550), n=NA, d=0.2,
           replications = 10000)

# get information from last printed graphic instead of saving
gg <- last_plot()
gg + coord_flip() # flip coordinates

# estimate sample sizes given varying power
powerCurve(p_t.test, n=NA, d=0.2, interval=c(10, 1000),
		   power=c(.2, .4, .6, .8))

# estimate power varying d
powerCurve(p_t.test, varying=seq(.1, 1, by=.2), n=50, d=NA)

# estimate d varying power
powerCurve(p_t.test, n=50, d=NA, interval=c(.01, 1),
		   power=c(.2, .4, .6, .8))

#####

# vary two inputs instead of one (second column uses colour aesthetic)
varying <- createDesign(n=c(30, 90, 270, 550),
                        d=c(.2, .5, .8))
powerCurve(p_t.test, varying=varying)

# extract data for alternative presentations
build <- ggplot_build(last_plot())
build

df <- build$plot$data
head(df)
ggplot(df, aes(n, power, linetype=d)) + geom_line()

# vary three inputs (third column uses facet_wrap)
varying <- createDesign(n=c(30, 90, 270),
                        var.equal=c(FALSE, TRUE),
                        d=c(.2, .5))
powerCurve(p_t.test, varying=varying, plotCI=FALSE)

}

}
\seealso{
\code{\link{Spower}}
}
