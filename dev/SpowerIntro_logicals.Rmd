---
title: "Spower with experiements that return logical vectors"
author: Phil Chalmers
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    number_sections: false
    toc: true
vignette: >
  %\VignetteIndexEntry{Introdution to the Spower package}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r include=FALSE}
library(Spower)
set.seed(42)
formals(Spower)$verbose <- formals(SpowerBatch)$verbose <- 
	formals(SpowerCurve)$verbose <- FALSE
formals(SpowerCurve)$plotly <- FALSE
```

The canonical way that *Spower* has been written by focusing primarily on $p$-values involving the null hypothesis to be tested ($P(X|H_0)$), or analogously the compliment of posterior probability for the alternative hypothesis in the Bayesian setting ($P(\neg H_1|X)=1 - P(H_1|X)$, where $P(H_1|X)$ is the posterior probability supporting the hypothesis of interest; often this is just $P(H_0|X)$).  

Without going into too much detail, the reason for setting the package up this way is so that the parameter $\alpha$ parameter (`sig.level`) could be used as the ubiquitous line-in-the-sand threshold to flag whether a hypothesis was rejected (under the null hypothesis) or supported probabilistically (under the probability of the null hypothesis setup through Bayesian analyses). However, it is often advantageous to return `logical` values direction in the simulation experiment as these can include more intricate experimental result requirements. 
This vignette showcases various ways that returning `logical` values works in the `Spower` package. Note that returning a logical in the simulation experiment necessarily means that the `sig.level` argument in `Spower()` and friends will not be used.

# Confidnece intervals

Keeping with the basic t-test experiment in the introduction vignetted, suppose we're interested in the power to reject the null hypothesis $H_0:\, \mu = \mu_0$ in a one-sample $t$-test scenario, where $P(X|H_0$) is the probability of the data given the null hypothesis. Normally, one could simply write an experiment that returns a $p$-value in this context, such as the following,

```{r}
p_single.t <- function(n, mean, mu=0){
	g <- rnorm(n, mean=mean)
	p <- t.test(g, mu=mu)$p.value
	p
}
```
However, an equivalent way to explore power in this context would be to investigate the same null hypothesis via confidence intervals given a specific $\alpha$ level, where $CI_\mu=[CI_{\alpha/2},CI_{1-\alpha/2}]$. If one were to take this approach, the define function must return a `logical` value instead, where the CI is utilize to evaluate the plausibility of $\mu = \mu_0$ by testing whether $\mu_0$ falls *outside*  the advertised interval. 

The following code demonstrates this logic, assuming that $\alpha = .05$ (and therefore a two-tailed, 95% CI is used), and uses the `is.outside_CI()` function to evaluate whether `mu` falls within the estimated `CI` returned from `t.test()`.

```{r}
l_single.t <- function(n, mean, mu=0, conf.level=.95){
	g <- rnorm(n, mean=mean)
	out <- t.test(g, mu=mu, conf.level=conf.level)
	CI <- out$conf.int
	is.outside_CI(mu, CI)   # equivalent to: !(CI[1] < mu && mu < CI[2])
}

l_single.t(100, mean=.2)
```

Running a power analysis with `Spower()` works out of the box now, where `p_single.t()` utilizes the `sig.level` argument in `Spower()` to construct an equivalent `TRUE/FALSE` expression internally, while `l_single.t()` ignores `sig.level` altogether.

```{r}
p_single.t(n=100, mean=.3) |> Spower()

l_single.t(n=100, mean=.3) |> Spower()
```

## Equivalence testing

Relatedly, though from a different perspective, there may be interest in evaluating power in the context of establishing *equivalence*, or in directional cases *superiority* or *non-inferiority*. The purpose of an equivalence tests is to establish that, although exact effects may exist, they are small enough to be considered practically equal in applications. For example, in an independent samples $t$-test, two groups might be considered "equivalent" if the true mean difference in the population is somewhere above $\epsilon_L$ but below $\epsilon_U$, where $\epsilon$s are  used to define the equivalence interval. If, for instance, two groups are equivalent then the null hypotheses to test using the two one-sided test (TOST) logic are 
$$H_{0a}:\, (\mu_1 - \mu_2) \le -\epsilon_L$$
and
$$H_{0b}:\,(\mu_1 - \mu_2) \ge \epsilon_U$$
Rejecting both of these null hypotheses leads to the induced complementary hypothesis of interest
$$H_1:\, \epsilon_L < (\mu_1 - \mu_2) < \epsilon_U$$
or in words, the population mean difference falls within the defined region of equivalence. Superiority testing and non-inferiority testing follow the same type of logic, however rather than defining a region of equivalence only one tail of the equivalence is of interest.

To put numbers to the above expression, suppose that the true mean difference between the groups was $\mu_d = \mu_1 - \mu_2 = 0.05$, however this effect is quite small and effectively equivalent to 0. Moreover, suppose any true difference that fell between $[-0.2, 0.2]$ were determined to be practically equivalent a priori. 

```{r}
l_equiv.t <- function(n, mean, equiv=c(-.2, .2), sig.level = .05){
	g1 <- rnorm(n)
	g2 <- rnorm(n, mean=mean)
	outL <- t.test(g2, g1, mu=-equiv[1], alternative = "less")$p.value
	outU <- t.test(g2, g1, mu=equiv[2], alternative = "less")$p.value
	outL < sig.level && outU < sig.level
}

l_equiv.t(100, mean=.05)
l_equiv.t(500, mean=.00)
```


```{r}
l_equiv.t(100, mean=.05) |> Spower()
l_equiv.t(100, mean=.05, equiv=c(-.1, .1)) |> Spower() # more narrow interval = less power
l_equiv.t(500, mean=.05) |> Spower()   # higher n = more power to establish equivalence
```

Again, the same type of logic can be evaluated using `CI`s alone.

```{r}
l_equiv.t_CI <- function(n, mean, equiv=c(-.2, .2), conf.level = .90){
	g1 <- rnorm(n)
	g2 <- rnorm(n, mean=mean)
	CI <- t.test(g2, g1, conf.level=conf.level)$conf.int
	is.CI_within(CI, equiv)  # returns TRUE if CI is within equiv interval
}

l_equiv.t_CI(100, mean=.05)
```

```{r}
# these are equivalent tests of "equivalent tests" 
l_equiv.t(100, mean=.05) |> Spower()
l_equiv.t_CI(100, mean=.05) |> Spower()   
```




# Region of Practical Equivalence (ROPEs)

Highly similar to the approach using equivalence intervals, but uses highest density interval instead.

https://easystats.github.io/bayestestR/articles/region_of_practical_equivalence.html


# Bayes Factors

$BF>3$ to provide moderate or greater evidence



